from typing import List, Dict, Optional, Any
from loguru import logger
import json

from app.schemas.browser_events import EventSegment
from app.schemas.tools import ToolsCatalog
from app.schemas.workflows import WorkflowSchema, WorkflowStepSchema
from app.services.utils import load_prompt
from openai import OpenAI
from app.core.config import settings


class GeneralizationService:
    """Service for generalizing workflows to make them reusable and not instance-bound"""

    def __init__(self):
        # Initialize OpenAI client
        self.client = OpenAI(api_key=settings.openai_api_key)
        self.llm_available = bool(settings.openai_api_key)

    async def generalize_workflow(self, segment: EventSegment, tools_catalog: ToolsCatalog) -> Optional[WorkflowSchema]:
        """
        Main method to generalize a workflow from an event segment using LLM analysis

        Args:
            segment: EventSegment to generalize
            tools_catalog: Available tools for the workflow

        Returns:
            Generalized WorkflowSchema or None if generalization fails
        """
        try:
            logger.info(f"Generalizing workflow for segment type: {segment.segment_type}")

            # Extract context for LLM analysis
            page_content = await self._extract_page_content(segment)
            user_actions = await self._extract_user_actions(segment)

            # Use LLM to generate complete workflow
            workflow_data = await self._generate_workflow_with_llm(
                segment=segment, page_content=page_content, user_actions=user_actions, tools_catalog=tools_catalog
            )

            if not workflow_data:
                logger.warning("No workflow generated by LLM")
                return None

            # Create workflow schema
            workflow = WorkflowSchema(
                id=None,  # Will be set when saving
                summary=workflow_data.get("summary", "Generated workflow"),
                steps=workflow_data.get("steps", []),
                domain=segment.domain,
                url_pattern=workflow_data.get("url_pattern"),
                confidence_score=0.0,
                is_active=True,
                execution_count=0,
                created_at=None,  # Will be set when saving
                updated_at=None,  # Will be set when saving
            )

            logger.info(f"Successfully generalized workflow: {workflow.summary}")
            return workflow

        except Exception as e:
            logger.error(f"Failed to generalize workflow: {str(e)}")
            return None

    async def _extract_page_content(self, segment: EventSegment) -> str:
        """Extract relevant page content from segment events"""
        content_parts = []

        for event in segment.events:
            if event.payload and event.payload.markdown:
                # Truncate very long markdown content
                markdown = event.payload.markdown
                if len(markdown) > 1000:
                    markdown = markdown[:1000] + "..."
                content_parts.append(f"Page: {event.title}\nContent: {markdown}")

            if event.payload and event.payload.text:
                content_parts.append(f"User input: {event.payload.text}")

        return "\n\n".join(content_parts) if content_parts else "No page content available"

    async def _generate_workflow_with_llm(
        self, segment: EventSegment, page_content: str, user_actions: str, tools_catalog: ToolsCatalog
    ) -> Optional[Dict[str, Any]]:
        """Generate complete workflow using LLM analysis"""

        if not self.llm_available:
            logger.warning("LLM not available - OpenAI API key not configured")
            return None

        try:
            llm_response = await self._call_llm_for_workflow(
                segment=segment, page_content=page_content, user_actions=user_actions, tools_catalog=tools_catalog
            )
            return await self._parse_llm_workflow_response(llm_response)
        except Exception as e:
            logger.error(f"Failed to generate workflow with LLM: {str(e)}")
            return None

    async def _call_llm_for_workflow(
        self, segment: EventSegment, page_content: str, user_actions: str, tools_catalog: ToolsCatalog
    ) -> str:
        """Call LLM to generate complete workflow"""

        # Prepare available tools list
        available_tools = [tool.name for tool in tools_catalog.tools] if tools_catalog.tools else []

        prompt = load_prompt(
            "workflow_generation.txt",
            variables={
                "segment_type": segment.segment_type,
                "domain": segment.domain,
                "page_content": page_content,
                "user_actions": user_actions,
                "available_tools": available_tools,
            },
        )

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "You are an expert workflow generator. Create reusable, generalized workflows from user interactions.",
                    },
                    {"role": "user", "content": prompt},
                ],
                temperature=0.3,
                max_tokens=2000,
            )

            return response.choices[0].message.content or ""

        except Exception as e:
            logger.error(f"OpenAI API call failed: {str(e)}")
            raise

    async def _parse_llm_workflow_response(self, llm_response: str) -> Optional[Dict[str, Any]]:
        """Parse LLM response into workflow data"""

        try:
            # Clean up the response - remove any markdown formatting
            cleaned_response = llm_response.strip()
            if cleaned_response.startswith("```json"):
                cleaned_response = cleaned_response[7:]
            if cleaned_response.endswith("```"):
                cleaned_response = cleaned_response[:-3]
            cleaned_response = cleaned_response.strip()

            # Parse JSON response
            workflow_data = json.loads(cleaned_response)

            # Convert steps to WorkflowStepSchema objects
            steps = []
            for step_data in workflow_data.get("steps", []):
                step = WorkflowStepSchema(
                    description=step_data.get("description", ""),
                    step_type=step_data.get("step_type", "tool"),
                    tools=step_data.get("tools", []),
                    tool_parameters=None,
                    context_selector=None,
                    context_description=step_data.get("context_description", ""),
                )
                steps.append(step)

            return {
                "summary": workflow_data.get("summary", ""),
                "steps": steps,
                "url_pattern": workflow_data.get("url_pattern", ""),
            }

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM JSON response: {str(e)}")
            logger.error(f"Response was: {llm_response}")
            return None
        except Exception as e:
            logger.error(f"Failed to parse LLM workflow response: {str(e)}")
            return None

    async def _extract_user_actions(self, segment: EventSegment) -> str:
        """Extract user actions summary from segment events"""
        actions = []

        for event in segment.events:
            if event.type == "click" and event.payload and event.payload.element:
                element = event.payload.element
                action_desc = f"Clicked on {element.tag}"
                if element.text:
                    action_desc += f" with text '{element.text}'"
                elif element.id:
                    action_desc += f" with id '{element.id}'"
                actions.append(action_desc)

            elif event.type == "type" and event.payload and event.payload.text:
                actions.append(f"Typed: '{event.payload.text}'")

            elif event.type == "page-load":
                actions.append(f"Loaded page: {event.title}")

        return "; ".join(actions) if actions else "No specific actions detected"
